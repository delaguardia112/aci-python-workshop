\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\newcommand{\code}{\texttt}

\usepackage{lastpage}

\usepackage{fancyhdr} 
\pagestyle{fancy}
\fancyhf{}
\rhead{Sushobhan Sen}
\lhead{ACI-UIUC Python Workshop}
\cfoot{\thepage\ of \pageref{LastPage}}

\usepackage{hyperref}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\begin{document}

%%%----------------------------------
%Settings for typesetting Python Code
%%%----------------------------------
\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,150,0}
 
\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        numbers=left}
        
%%%----------------------------------

\begin{titlepage}
	\centering
	{\LARGE American Concrete Institute (ACI)-UIUC Student Chapter}
	\vspace{2cm}	
	
	\begin{Large}
	Python Workshop (Basic and Advanced)
	\vspace{1cm}
	
	\textbf{Sushobhan Sen}
	\vspace{1cm}
	
	Doctoral Candidate
	\vspace{1cm}
	
	April 6, 2019
	\vspace{1cm}
	
	Urbana, IL
	\end{Large}
\end{titlepage}

Copyright \copyright\ 2019, Sushobhan Sen

\doclicenseThis
\newpage

\tableofcontents
\newpage

\section{Introduction}
\subsection{Why Python?}
The Python programming language was conceived in the 1980s and the first implementation was deployed in 1991 by Guido van Rossum at Centrum Wiskunde \& Informatica (CWI) in the Netherlands. Python is designed to be a high-level, interpreted, general-purpose computer programming language with exception-handling and the ability to be extended by users. Crucially, Python is an open-source language, meaning anybody can see the code behind it. Python today is a very popular language is a broad variety of disciplines: machine learning, web development, Geographical Information Systems (GIS), engineering, database management, high performance computing, etc.

Python 2.0, which truly launched the popularity of the language, was released in 2000, with the last version in the series, Python 2.7, set to be phased out in 2020. The current recommended standard as of when I wrote this is Python 3.7.2, which is crucially \textbf{not backwards compatible} with Python 2.x. All subversions of Python 3.x are backwards compatible though, so feel free to update regularly.

(The above information was taken from \href{https://en.wikipedia.org/wiki/Python_(programming_language)}{Wikipedia})

The beauty of Python is its ease - the syntax is extremely simple as compared to many other popular programming languages. It is often said, not entirely without truth, that the difference between Python code and pseudo-code is merely the indentation. Thus, the language is very easy to learn for programming novices. However, its ease should not be misconstrued to mean that it is only for easy or trivial applications: Python is an extremely powerful language with a wide variety of applications, it has extensive documentation, and its open-source nature ensures that new features are being developed continuously while bugs are also being fixed.

\subsection{Learning Objectives}
This workshop is broken up into two sessions:

\begin{enumerate}
	\item A Basic Python session for beginners with zero knowledge of programming in any language
	\item An Advanced Python session for those with prior knowledge of Python programming
\end{enumerate}

At the end of the \textbf{Basic Python} session, participants will be able to:

\begin{enumerate}
	\item List the types of Python variables and define them
	\item Add control statements (\code{if-then-else}) and \code{for} loops to their program
	\item Define and use functions
	\item Define and use object oriented programming
\end{enumerate}

At the end of the \textbf{Advanced Python} session, participants will be able to:

\begin{enumerate}
	\item Use the \code{numpy} library to define and use matrices, and read and process data from files
	\item Use the \code{pandas} library to read and process data
	\item Use the \code{scipy} library to solve a system if linear equations and implement other useful scientific functions
	\item Use the \code{matplotlib} library to create publication-quality plots
\end{enumerate}

The lists above ware what I will try to accomplish in our two two-hour long sessions. Depending on how quickly the workshop goes, I may or may not be able to meet all the learning objectives. However, I will get you along far enough so that you can complete any remaining items on your own.

\subsection{Installing Python}
The easiest and \textbf{recommended} way to get all popular Python libraries and IDEs is by downloading and installing the latest \href{https://www.anaconda.com/distribution/}{Anaconda distribution} for your computer. Make sure to download the latest version corresponding to Python 3.x.

Alternatively, you can install and use Python using the terminal: 

\begin{itemize}
	\item On Windows 10, activate \href{https://docs.microsoft.com/en-us/windows/wsl/install-win10}{Windows Subsystem for Linux}
	\item On Mac OS or any UNIX-like OS (such as Linux), just run your favorite Terminal application
\end{itemize}

Then install \href{https://jupyter.org/install}{Jupyter} with \code{pip}. With any other version of Windows (which you should not be using for too long on your personal computers anyway for security reasons), Anaconda is your best option.

Once installed, you can now create a new notebook. If you installed Anaconda, open the Anaconda Prompt, navigate to your directory, and use the \code{jupyter notebook} command. If you choose to use the terminal, follow the same steps on the terminal. Both methods will launch Jupyter Notebooks in your browser. From there, you can create a new Notebook.

If you prefer not to install anything on your computer but would rather run Python remotely from your browser, you can use the Online IDE from \href{https://repl.it/languages/python3}{repl.it}. This doesn't always work very well though. Any other online IDE that you find should be OK too.

\newpage

\section{Variables in Python}
\subsection{Data Types}
Python defines the following data types for variables:

\begin{center}
\begin{tabular}{|p{0.75in}|p{1in}|p{1.5in}|p{1.5in}|}
\hline
\textbf{Data Type} & \textbf{Syntax} & \textbf{Description} & \textbf{Comments} \\ \hline
Integer & \code{x = 5} & Signed integer & Use \code{int} to typecast, if valid \\ \hline
Float & \code{x = 5.} & IEEE floating point number & Use \code{float} to typecast, if valid \\ \hline
Complex & \code{x = 3.1+4.6j} & Complex number & Use \code{complex} to typecast, if valid \\ \hline
String & \code{x = 'Hello World!'} & Strings are always enclosed within quotation marks & Use \code{str} to typecast, slicing operator valid \\ \hline
List & \code{x = [1, 2.2, 'otter']} & \textbf{Mutable} list of variables of any type & Use \code{list()} to typecast, if valid \\ \hline
Tuple & \code{x = (1, 2.2, 'otter')} & Immutable tuple of variables of any tupe & Use \code{tuple()} to typecast, if valid \\ \hline
Dictionary & \texttt{x = \{'one':1, 'two':2\}} & Key-value pairs & Use \code{get()} to get \code{value} from \code{key}, use \code{dict()} to typecast, if valid \\ \hline
Bool & \code{x = True} & Boolean value & Python uses keywords \code{True} and \code{False}, not 1 and 0 \\ \hline

\end{tabular}
\end{center}

\subsection{Creating a Variable}
Variables are usually given a name, which is any string of characters you use to call it. Any string of characters is a valid name, although there are a couple of rules to follow:

\begin{enumerate}
	\item The name \textbf{cannot} contain spaces - consider using an underscore character or chamelCase instead for readability
	\item The name cannot start with a number, but can contain a number anywhere
	\item The name is case-sensitive, so \code{temp} and \code{Temp} are different variables
	\item Python has a number of reserved keywords (see documentation, of just follow along and you'll get the hang of it), which cannot be used as names
\end{enumerate}

Creating a variable is as simple as giving it a name, and assigning a value to it. For example, run this piece of code:

\begin{lstlisting}[frame=single] 
x = 1.0
y = 'Hello, World!'
z = (x==y)
print(type(x),type(y),type(z),z)
\end{lstlisting}

Here, we defined three variables: \code{x} of type \code{int}, \code{y} of type \code{str}, and \code{z} of type \code{bool}. Note that the \code{==} is a comparison operator that compares two values, while \code{=} is an assignment operator that assigns a value to a variable. The \code{print()} function, as the name suggests, prints the comma-separated inputs as a string , while the \code{type()} function returns the data type of the input. Note that every new line of code in Python starts on a new line, and \textbf{there is no end of line character} (such as a semi-colon in many languages).

\subsection{Mutability}

Some Python data types are \textbf{immutable}. This means that, once defined, ibjects of those types cannot be changed without creating a new object entirely. Most objects are immutable: \code{int, float, complex, str, bool, tuple} are immutable. If you try to change their values, you will either get an error or a new object containing the new value will be created. For example, run the following code, where \code{id()} is a function that returns the memory location of the object passed to it:

\begin{lstlisting}[frame=single] 
x = 1
print(id(x))
x = 2.0
print(id(x))
\end{lstlisting}

You'll see that the memory location of \code{x} has changed entirely, instead of just the value being changed. This is because \code{x} was defined as type \code{int}, which is immutable. Similarly, try changing the value inside a tuple and see what happens (note that \code{x[0]} is a way to reference the first element of \code{x} - \textbf{Python is zero-indexed}):

\begin{lstlisting}[frame=single] 
x = (1,2,3)
x[0] = 10
print(x)
\end{lstlisting}

Lists and dictionaries are mutable, which means their values can be changed at any time. Try running the following code and compare it to the last one: 

\begin{lstlisting}[frame=single] 
x = [1,2,3]
print(id(x))
x[0] = 10
print(id(x))
print(x)
\end{lstlisting}

\subsection{Operations on Variables}
Python provides a number of operations that can be performed between variables:

\begin{itemize}
	\item \textbf{Arithmetic operators:} + (add), - (subtract), * (multiply), / (divide), \% (modulus or remainder), // (floor division), ** (exponent)
	\item \textbf{Comparison operators:} $>$ (grater than), $<$ (less than), == (equal to), != (not equal to), $>=$ (greater than or equal to), $<=$ (less than or equal to)
	\item \textbf{Logical operators:} \code{and}, \code{or}, and \code{not}
	\item \textbf{Bitwise operators:} \& (bitwise AND), \textbar\ (bitwise OR), $\sim$ (bitwise NOT),  (bitwise XOR), $>>$ (bitwise right shift), $<<$ (bitwise left shift)
	\item \textbf{Assignment operators:} A combination of the basic assignment operator (=) and an optional arithmetic or bitwise operator. For example, \code{x **= 5} is the same as \code{x = x**5}
	\item \textbf{Special operators:} \code{is} or \code{is not} check if two variables have the same memory address, \code{in} or \code{not in} check if a variable is in a sequences of variables
\end{itemize}

Operators are mostly self-explanatory, but their behavior can be different based on the data type of the input variables. Consider adding two integers, adding an integer to a float, adding two strings, and adding an integer to a string, all of which use the same + operator:

\begin{lstlisting}[frame=single] 
x = 2
print(x+2)
print(x+2.5)
print('Goodbye'+'Hello')
print(x+'Hello')
\end{lstlisting}

The first operation is as expected and returns an integer. In the second operation, \code{x} is first typecast to \code{float} \textit{implicitly} (the program does it by itself) and then added to another float to return a float. In the third operation, two strings are simply concatenated together to return another string. 

However, the last operation of adding an integer to a string returns an error, because Python is unable to figure out which variable to cast to which type. Of course, casting a string to an integer makes no sense, but Python doesn't even try, because it's unsure about what to do. You can help it by \textit{explicitly} casting \code{x} from an integer to string, and then see what happens:

\begin{lstlisting}[frame=single] 
x = 2
print(str(x)+'Hello')
\end{lstlisting}

\newpage

\section{Control Statements}
Control statements are blocks of code that are used to control the flow of the program - that could mean skipping some lines, or repeating some lines a certain number of times. There are two main types of control statements:

\begin{enumerate}
	\item \textbf{Conditional statements}: Better known as if-else blocks, these test a condition before executing a line
	\item \textbf{Loops}: These repeatedly execute a line for a certain number of times or till a break condition is met 
\end{enumerate}

We'll look at each of these below.

\subsection{Conditional Statements}
The most basic control statement is an \code{if} statement, which checks a condition and executes the code after it only if the condition evaluates \code{True}. Consider the following block of code:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
    print('Finished evaluating if block')
print('Finished this code block')
\end{lstlisting}

First, notice the syntax: the \code{if} statement starts with the word itself, followed by a space, and followed by the condition (\code{x<5}). This line then ends with a colon (:), signifying that things after the colon are to be executed if the condition returns \code{True}. But how do you tell Python what lines of code are part of the \code{if}-statement to be executed, and what are not? In other words, how do you signify the scope of the \code{if}-statement? In this case, we want the two \code{print()} statements after the \code{if}-statement to be executed only if the condition return \code{True}, while the third \code{print()} statement to be executed regardless. How do we tell it to do that?

That's where indentation (a tab character, usually four spaces long) comes into play. In many computer languages, a whitespace like a tab character is simply ignored. However, in Python, it is an \textit{integral part} of the code - \textbf{this is a major different between Python and other languages!} Mistakes made with indentation can and will return an error, so be careful. 

Now, coming back to the code. We want the first two \code{print()} statements to be executed only if the condition is True, so we indent them by one level (one tab character) with respect to the indentation level of the \code{if}-statement. The additional indentation level makes these lines associated with the parent line. Whereas, we don't want to last \code{print()} statement to be associated with the \code{if}-statement, so we keep it at the same indentation level as the statement, signifying that there is no association or dependency between them. This can seem confusing at first, but it is a very elegant way of writing code and is indeed, almost the same as writing pseudo-code.

To drive home the point, let's put an \code{if}-statement within another \code{if}-statement:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
    print('Finished evaluating outer if block')
    
    if x>2:
        print('but x is greater than 2')
        print('Finished evaluating inner if block')
print('Finished this code block')
\end{lstlisting}

Now see the indentation here. The inner \code{if}-statement is one indentation level after the outer one, indicating that it will be executed only if the outer condition is true. And the \code{print()} statements associated with the inner statement is at yet another indentation level (two tab characters) or one character after the inner \code{if}-statement, indicating that they will be executed only if the inner statement is true. This indentation, unlike a lot of languages, is \textbf{not optional}. Python has no other way of knowing which lines of code are associated with which control statement without proper indentation. 

The code above is simple enough, but can actually be combined by using a logical operator to combine both \code{if}-statements:

\begin{lstlisting}[frame=single] 
x = 6
if x<5 and x>2:
    print('x is less than 5 and greater than 2')
    print('Finished evaluating  if block')
print('Finished this code block')
\end{lstlisting}

Thus, logical operators can be used to write more concise conditional statements, and they can even be nested together into increasingly complex conditions.

It is however common for conditional evaluations to be binary in nature - if something is true, do this thing, or else do this other thing. In principle, this could be achieved by using two \code{if}-statements one after the other:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
if x>5:
    print('x is greater than 5')
print('Finished this code block')
\end{lstlisting}

However, this is an unnecessary evaluation: if \code{x<5} is \code{False}, it automatically follows that \code{x>5} is \code{True} (except for one case, which we'll see in a bit), so there's no need to check again. Thus, Python has an \code{if-else} statement that implements just that idea:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
else:
    print('x is greater than 5')
print('Finished this code block')
\end{lstlisting}

Note again how the line after \code{else} is indented after the colon, signifying an association between the two.

If you're alert, you'll nice that \code{x==5} is a third possibility. We could add another \code{if} statement for it, or we could group the three conditions together into an \code{if-elif-else} block:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
elif x>5:
    print('x is greater than 5')
else:
    print('x is equal to 5')
print('Finished this code block')
\end{lstlisting}

Here, "elif" is short for "else if". It is not necessary to use \code{elif} statements, but it is recommended because it makes the code more readable. Once again, notice the indentation and which lines are associated with which. 

Note that the last else statement could've been replaced with an \code{elif x==5:} statement. However, it is usually good practice to end the \code{if-elif-else} block with an \code{else} statement as a fail-safe case to catch all other possible outcomes, both expected and unexpected.

\subsection{Loops}
Loops are blocks of code that are executed repeatedly either for a fixed number of times, or till a break condition is satisfied. Loop statements offer a convenient way to execute code repeatedly without having to write very long, unwieldy programs. Python offers two types of loops: \code{while} and \code{for} loops. Let's look at these individually. 

\code{While} loops execute a block of statements (grouped by indentation) as long as a condition is true. Consider the following code, which prints a number and increments it until it reaches a threshold:

\begin{lstlisting}[frame=single] 
x = 3
while(x<6):
    print('The value of x is ',x)
    x+=1
\end{lstlisting}

Here, \code{x} is set to 3. When the \code{while} loop begins, the condition \code{x<6} is evaluated and if it is true, the associated lines of code (which are indented by one level more than the \code{while} statement) are executed. In this case, the condition is true, so first the value of \code{x} is printed, and then it is incremented by 1. At this point, control returns (or 'loops back') to the \code{while} statement, and the condition is evaluated again. This is why it's called a loop. The loop continues to iterate until the condition is \code{False}, at which point any code after the loop and its associated lines are executed till the program ends.

\code{While} loops are used when the number of times the code has to run is unknown. However, a more common case is that the lines of code are executed for a fixed number of times. The \code{While} loop could be 'hacked' by coming up a with a condition that runs for a fixed number of times (like the example above), but there's a better way: \code{for} loops. These types of loops are extremely common, and most programming languages offer them. Compared to many other popular languages though, Python's \code{for} loop works a little differently: it is an iterator-based loop, similar to the \code{foreach} loop provided in C\# and VBA, or a version of the \code{for} loop in Java. It is not the same as the \code{for} loop used in C/C++.

An iterator is a specific type of Python object that allows the program to traverse through all the elements in a sequence (tuples, lists, or dictionaries), regardless of how that sequence is implemented. And since sequences have a fixed length at any point of time in a code, iterating through them is equivalent to running a loop for a fixed number of times. Consider the following block of code:

\begin{lstlisting}[frame=single] 
x = range(3)
print(list(x))
for i in x:
    print('The value of i is ',i)
\end{lstlisting}

Here, \code{range()} is a function that returns a fixed number of \textit{integers} (\textit{not floats}), \textit{starting from 0 by default}, although the default behavior can be modified (see \href{https://docs.python.org/3/library/functions.html#func-range}{documentation}). The return type is an iterable \code{range} object, which can be cast into a list type to see its contents - in this case, it's a list \code{[0,1,2]}.

Next, the \code{for} loop defines a variable \code{i} which is in \code{x}. This means that the variable \code{i} traverses through each the value in \code{x} in each iteration, until it runs out of values to traverse. Execute the function to print \code{i} and see this for yourself. 

The beauty of this approach in Python and perhaps the most startling difference between it and the \code{for} loop in C/C++ is that the iterator can have any implementation - it can contain anything, not just numbers! Consider this example:

\begin{lstlisting}[frame=single] 
for i in ['Harry',(0,1,2),1]:
    print(i)
\end{lstlisting}

Here, \code{i} iterates over a list, which itself is composed of three items of three different data types: a string, a tuple (yes, a list can hold a tuple, or even another list), and an integer. And it does this naturally, without any additional code or typecasting necessary. This is a really big deal!

And it gets better - a single \code{for} loop can have more than one loop variable. Consider the following example:

\begin{lstlisting}[frame=single] 
x = [0,1,2]
y = [10,11,12]
z = [21,22,23]
print(list(zip(x,y,z)))
for i,j,k in zip(x,y,z):
    print(i,'+',j,'+',k,'=',i+j)
\end{lstlisting}

Here, the \code{zip()} function (see \href{https://docs.python.org/3.3/library/functions.html#zip}{documentation}) takes three lists (or technically, iterable objects) \textit{of the same length} (or it truncates to the shortest length) and combines them into an iterable object of tuples, with each tuple having three members. Then, the \code{for} loop \textbf{unpacks} the tuples into the constituent members, which can then be iterated over \textit{simultaneously}. Python also provides several functions to efficiently create complex iterable objects through the itertools package (see \href{https://docs.python.org/3/library/itertools.html}{documentation}). We'll see how to import a package later.  

Finally, because the \code{for} loop is based on an iterator, it can actually be used anywhere in a line of code, and not just in a formal loop. Consider the following piece of code, which creates a list of the squares of the first five whole numbers in just one line:

\begin{lstlisting}[frame=single] 
x = [i**2 for i in range(5)]
print(x)
\end{lstlisting}

This feature makes writing Python loops particularly elegant and simple.

\newpage
\section{Functions}
In just a few pages, we've already learned all the basic building blocks on any Python code. 

\end{document}