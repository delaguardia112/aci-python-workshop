\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\newcommand{\code}{\texttt}

\usepackage{lastpage}

\usepackage{fancyhdr} 
\pagestyle{fancy}
\fancyhf{}
\rhead{Sushobhan Sen}
\lhead{ACI-UIUC Python Workshop}
\cfoot{\thepage\ of \pageref{LastPage}}

\usepackage{hyperref}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\begin{document}

%%%----------------------------------
%Settings for typesetting Python Code
%%%----------------------------------
\definecolor{keywords}{RGB}{255,0,90}
\definecolor{comments}{RGB}{0,0,113}
\definecolor{red}{RGB}{160,0,0}
\definecolor{green}{RGB}{0,150,0}
 
\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        numbers=left}
        
%%%----------------------------------

\begin{titlepage}
	\centering
	{\LARGE American Concrete Institute (ACI)-UIUC Student Chapter}
	\vspace{2cm}	
	
	\begin{Large}
	Python Workshop (Basic and Advanced)
	\vspace{1cm}
	
	\textbf{Sushobhan Sen}
	\vspace{1cm}
	
	Doctoral Candidate
	\vspace{1cm}
	
	April 6, 2019
	\vspace{1cm}
	
	Urbana, IL
	\end{Large}
\end{titlepage}

Copyright \copyright\ 2019, Sushobhan Sen

\doclicenseThis
\newpage

\tableofcontents
\newpage

\section{Introduction}
\subsection{Why Python?}
The Python programming language was conceived in the 1980s and the first implementation was deployed in 1991 by Guido van Rossum at Centrum Wiskunde \& Informatica (CWI) in the Netherlands. Python is designed to be a high-level, interpreted, general-purpose computer programming language with exception-handling and the ability to be extended by users. Crucially, Python is an open-source language, meaning anybody can see the code behind it. Python today is a very popular language is a broad variety of disciplines: machine learning, web development, Geographical Information Systems (GIS), engineering, database management, high performance computing, etc.

Python 2.0, which truly launched the popularity of the language, was released in 2000, with the last version in the series, Python 2.7, set to be phased out in 2020. The current recommended standard as of when I wrote this is Python 3.7.2, which is crucially \textbf{not backwards compatible} with Python 2.x. All subversions of Python 3.x are backwards compatible though, so feel free to update regularly.

(The above information was taken from \href{https://en.wikipedia.org/wiki/Python_(programming_language)}{Wikipedia})

The beauty of Python is its ease - the syntax is extremely simple as compared to many other popular programming languages. It is often said, not entirely without truth, that the difference between Python code and pseudo-code is merely the indentation. Thus, the language is very easy to learn for programming novices. However, its ease should not be misconstrued to mean that it is only for easy or trivial applications: Python is an extremely powerful language with a wide variety of applications, it has extensive documentation, and its open-source nature ensures that new features are being developed continuously while bugs are also being fixed.

\subsection{Learning Objectives}
This workshop is broken up into two sessions:

\begin{enumerate}
	\item A Basic Python session for beginners with zero knowledge of programming in any language
	\item An Advanced Python session for those with prior knowledge of Python programming
\end{enumerate}

At the end of the \textbf{Basic Python} session, participants will be able to:

\begin{enumerate}
	\item List the types of Python variables and define them
	\item Add control statements (\code{if-then-else}) and \code{for} loops to their program
	\item Define and use functions
	\item Define and use object oriented programming
\end{enumerate}

At the end of the \textbf{Advanced Python} session, participants will be able to:

\begin{enumerate}
	\item Use the \code{numpy} library to define and use matrices, and read and process data from files
	\item Use the \code{pandas} library to read and process data
	\item Use the \code{scipy} library to solve a system if linear equations and implement other useful scientific functions
	\item Use the \code{matplotlib} library to create publication-quality plots
\end{enumerate}

The lists above ware what I will try to accomplish in our two two-hour long sessions. Depending on how quickly the workshop goes, I may or may not be able to meet all the learning objectives. However, I will get you along far enough so that you can complete any remaining items on your own.

\subsection{Installing Python}
The easiest and \textbf{recommended} way to get all popular Python libraries and IDEs is by downloading and installing the latest \href{https://www.anaconda.com/distribution/}{Anaconda distribution} for your computer. Make sure to download the latest version corresponding to Python 3.x.

Alternatively, you can install and use Python using the terminal: 

\begin{itemize}
	\item On Windows 10, activate \href{https://docs.microsoft.com/en-us/windows/wsl/install-win10}{Windows Subsystem for Linux}
	\item On Mac OS or any UNIX-like OS (such as Linux), just run your favorite Terminal application
\end{itemize}

Then install \href{https://jupyter.org/install}{Jupyter} with \code{pip}. With any other version of Windows (which you should not be using for too long on your personal computers anyway for security reasons), Anaconda is your best option.

Once installed, you can now create a new notebook. If you installed Anaconda, open the Anaconda Prompt, navigate to your directory, and use the \code{jupyter notebook} command. If you choose to use the terminal, follow the same steps on the terminal. Both methods will launch Jupyter Notebooks in your browser. From there, you can create a new Notebook.

If you prefer not to install anything on your computer but would rather run Python remotely from your browser, you can use the Online IDE from \href{https://repl.it/languages/python3}{repl.it}. This doesn't always work very well though. Any other online IDE that you find should be OK too.

\newpage

\section{Variables in Python}
\subsection{Data Types}
Python defines the following data types for variables:

\begin{center}
\begin{tabular}{|p{0.75in}|p{1in}|p{1.5in}|p{1.5in}|}
\hline
\textbf{Data Type} & \textbf{Syntax} & \textbf{Description} & \textbf{Comments} \\ \hline
Integer & \code{x = 5} & Signed integer & Use \code{int} to typecast, if valid \\ \hline
Float & \code{x = 5.} & IEEE floating point number & Use \code{float} to typecast, if valid \\ \hline
Complex & \code{x = 3.1+4.6j} & Complex number & Use \code{complex} to typecast, if valid \\ \hline
String & \code{x = 'Hello World!'} & Strings are always enclosed within quotation marks & Use \code{str} to typecast, slicing operator valid \\ \hline
List & \code{x = [1, 2.2, 'otter']} & \textbf{Mutable} list of variables of any type & Use \code{list()} to typecast, if valid \\ \hline
Tuple & \code{x = (1, 2.2, 'otter')} & Immutable tuple of variables of any tupe & Use \code{tuple()} to typecast, if valid \\ \hline
Dictionary & \texttt{x = \{'one':1, 'two':2\}} & Key-value pairs & Use \code{get()} to get \code{value} from \code{key}, use \code{dict()} to typecast, if valid \\ \hline
Bool & \code{x = True} & Boolean value & Python uses keywords \code{True} and \code{False}, not 1 and 0 \\ \hline

\end{tabular}
\end{center}

\subsection{Creating a Variable}
Variables are usually given a name, which is any string of characters you use to call it. Any string of characters is a valid name, although there are a couple of rules to follow:

\begin{enumerate}
	\item The name \textbf{cannot} contain spaces - consider using an underscore character or chamelCase instead for readability
	\item The name cannot start with a number, but can contain a number anywhere
	\item The name is case-sensitive, so \code{temp} and \code{Temp} are different variables
	\item Python has a number of reserved keywords (see documentation, of just follow along and you'll get the hang of it), which cannot be used as names
\end{enumerate}

Creating a variable is as simple as giving it a name, and assigning a value to it. For example, run this piece of code:

\begin{lstlisting}[frame=single] 
x = 1.0
y = 'Hello, World!'
z = (x==y)
print(type(x),type(y),type(z),z)
\end{lstlisting}

Here, we defined three variables: \code{x} of type \code{int}, \code{y} of type \code{str}, and \code{z} of type \code{bool}. Note that the \code{==} is a comparison operator that compares two values, while \code{=} is an assignment operator that assigns a value to a variable. The \code{print()} function, as the name suggests, prints the comma-separated inputs as a string , while the \code{type()} function returns the data type of the input. Note that every new line of code in Python starts on a new line, and \textbf{there is no end of line character} (such as a semi-colon in many languages).

\subsection{Mutability}

Some Python data types are \textbf{immutable}. This means that, once defined, ibjects of those types cannot be changed without creating a new object entirely. Most objects are immutable: \code{int, float, complex, str, bool, tuple} are immutable. If you try to change their values, you will either get an error or a new object containing the new value will be created. For example, run the following code, where \code{id()} is a function that returns the memory location of the object passed to it:

\begin{lstlisting}[frame=single] 
x = 1
print(id(x))
x = 2.0
print(id(x))
\end{lstlisting}

You'll see that the memory location of \code{x} has changed entirely, instead of just the value being changed. This is because \code{x} was defined as type \code{int}, which is immutable. Similarly, try changing the value inside a tuple and see what happens (note that \code{x[0]} is a way to reference the first element of \code{x} - \textbf{Python is zero-indexed}):

\begin{lstlisting}[frame=single] 
x = (1,2,3)
x[0] = 10
print(x)
\end{lstlisting}

Lists and dictionaries are mutable, which means their values can be changed at any time. Try running the following code and compare it to the last one: 

\begin{lstlisting}[frame=single] 
x = [1,2,3]
print(id(x))
x[0] = 10
print(id(x))
print(x)
\end{lstlisting}

\subsection{Operations on Variables}
Python provides a number of operations that can be performed between variables:

\begin{itemize}
	\item \textbf{Arithmetic operators:} + (add), - (subtract), * (multiply), / (divide), \% (modulus or remainder), // (floor division), ** (exponent)
	\item \textbf{Comparison operators:} $>$ (grater than), $<$ (less than), == (equal to), != (not equal to), $>=$ (greater than or equal to), $<=$ (less than or equal to)
	\item \textbf{Logical operators:} \code{and}, \code{or}, and \code{not}
	\item \textbf{Bitwise operators:} \& (bitwise AND), \textbar\ (bitwise OR), $\sim$ (bitwise NOT),  (bitwise XOR), $>>$ (bitwise right shift), $<<$ (bitwise left shift)
	\item \textbf{Assignment operators:} A combination of the basic assignment operator (=) and an optional arithmetic or bitwise operator. For example, \code{x **= 5} is the same as \code{x = x**5}
	\item \textbf{Special operators:} \code{is} or \code{is not} check if two variables have the same memory address, \code{in} or \code{not in} check if a variable is in a sequences of variables
\end{itemize}

Operators are mostly self-explanatory, but their behavior can be different based on the data type of the input variables. Consider adding two integers, adding an integer to a float, adding two strings, and adding an integer to a string, all of which use the same + operator:

\begin{lstlisting}[frame=single] 
x = 2
print(x+2)
print(x+2.5)
print('Goodbye'+'Hello')
print(x+'Hello')
\end{lstlisting}

The first operation is as expected and returns an integer. In the second operation, \code{x} is first typecast to \code{float} \textit{implicitly} (the program does it by itself) and then added to another float to return a float. In the third operation, two strings are simply concatenated together to return another string. 

However, the last operation of adding an integer to a string returns an error, because Python is unable to figure out which variable to cast to which type. Of course, casting a string to an integer makes no sense, but Python doesn't even try, because it's unsure about what to do. You can help it by \textit{explicitly} casting \code{x} from an integer to string, and then see what happens:

\begin{lstlisting}[frame=single] 
x = 2
print(str(x)+'Hello')
\end{lstlisting}

\newpage

\section{Control Statements}
Control statements are blocks of code that are used to control the flow of the program - that could mean skipping some lines, or repeating some lines a certain number of times. There are two main types of control statements:

\begin{enumerate}
	\item \textbf{Conditional statements}: Better known as if-else blocks, these test a condition before executing a line
	\item \textbf{Loops}: These repeatedly execute a line for a certain number of times or till a break condition is met 
\end{enumerate}

We'll look at each of these below.

\subsection{Conditional Statements}
The most basic control statement is an \code{if} statement, which checks a condition and executes the code after it only if the condition evaluates \code{True}. Consider the following block of code:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
    print('Finished evaluating if block')
print('Finished this code block')
\end{lstlisting}

First, notice the syntax: the \code{if} statement starts with the word itself, followed by a space, and followed by the condition (\code{x<5}). This line then ends with a colon (:), signifying that things after the colon are to be executed if the condition returns \code{True}. But how do you tell Python what lines of code are part of the \code{if}-statement to be executed, and what are not? In other words, how do you signify the scope of the \code{if}-statement? In this case, we want the two \code{print()} statements after the \code{if}-statement to be executed only if the condition return \code{True}, while the third \code{print()} statement to be executed regardless. How do we tell it to do that?

That's where indentation (a tab character, usually four spaces long) comes into play. In many computer languages, a whitespace like a tab character is simply ignored. However, in Python, it is an \textit{integral part} of the code - \textbf{this is a major different between Python and other languages!} Mistakes made with indentation can and will return an error, so be careful. 

Now, coming back to the code. We want the first two \code{print()} statements to be executed only if the condition is True, so we indent them by one level (one tab character) with respect to the indentation level of the \code{if}-statement. The additional indentation level makes these lines associated with the parent line. Whereas, we don't want to last \code{print()} statement to be associated with the \code{if}-statement, so we keep it at the same indentation level as the statement, signifying that there is no association or dependency between them. This can seem confusing at first, but it is a very elegant way of writing code and is indeed, almost the same as writing pseudo-code.

To drive home the point, let's put an \code{if}-statement within another \code{if}-statement:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
    print('Finished evaluating outer if block')
    
    if x>2:
        print('but x is greater than 2')
        print('Finished evaluating inner if block')
print('Finished this code block')
\end{lstlisting}

Now see the indentation here. The inner \code{if}-statement is one indentation level after the outer one, indicating that it will be executed only if the outer condition is true. And the \code{print()} statements associated with the inner statement is at yet another indentation level (two tab characters) or one character after the inner \code{if}-statement, indicating that they will be executed only if the inner statement is true. This indentation, unlike a lot of languages, is \textbf{not optional}. Python has no other way of knowing which lines of code are associated with which control statement without proper indentation. 

The code above is simple enough, but can actually be combined by using a logical operator to combine both \code{if}-statements:

\begin{lstlisting}[frame=single] 
x = 6
if x<5 and x>2:
    print('x is less than 5 and greater than 2')
    print('Finished evaluating  if block')
print('Finished this code block')
\end{lstlisting}

Thus, logical operators can be used to write more concise conditional statements, and they can even be nested together into increasingly complex conditions.

It is however common for conditional evaluations to be binary in nature - if something is true, do this thing, or else do this other thing. In principle, this could be achieved by using two \code{if}-statements one after the other:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
if x>5:
    print('x is greater than 5')
print('Finished this code block')
\end{lstlisting}

However, this is an unnecessary evaluation: if \code{x<5} is \code{False}, it automatically follows that \code{x>5} is \code{True} (except for one case, which we'll see in a bit), so there's no need to check again. Thus, Python has an \code{if-else} statement that implements just that idea:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
else:
    print('x is greater than 5')
print('Finished this code block')
\end{lstlisting}

Note again how the line after \code{else} is indented after the colon, signifying an association between the two.

If you're alert, you'll nice that \code{x==5} is a third possibility. We could add another \code{if} statement for it, or we could group the three conditions together into an \code{if-elif-else} block:

\begin{lstlisting}[frame=single] 
x = 6
if x<5:
    print('x is less than 5')
elif x>5:
    print('x is greater than 5')
else:
    print('x is equal to 5')
print('Finished this code block')
\end{lstlisting}

Here, "elif" is short for "else if". It is not necessary to use \code{elif} statements, but it is recommended because it makes the code more readable. Once again, notice the indentation and which lines are associated with which. 

Note that the last else statement could've been replaced with an \code{elif x==5:} statement. However, it is usually good practice to end the \code{if-elif-else} block with an \code{else} statement as a fail-safe case to catch all other possible outcomes, both expected and unexpected.

\subsection{Loops}
Loops are blocks of code that are executed repeatedly either for a fixed number of times, or till a break condition is satisfied. Loop statements offer a convenient way to execute code repeatedly without having to write very long, unwieldy programs. Python offers two types of loops: \code{while} and \code{for} loops. Let's look at these individually. 

\code{While} loops execute a block of statements (grouped by indentation) as long as a condition is true. Consider the following code, which prints a number and increments it until it reaches a threshold:

\begin{lstlisting}[frame=single] 
x = 3
while(x<6):
    print('The value of x is ',x)
    x+=1
\end{lstlisting}

Here, \code{x} is set to 3. When the \code{while} loop begins, the condition \code{x<6} is evaluated and if it is true, the associated lines of code (which are indented by one level more than the \code{while} statement) are executed. In this case, the condition is true, so first the value of \code{x} is printed, and then it is incremented by 1. At this point, control returns (or 'loops back') to the \code{while} statement, and the condition is evaluated again. This is why it's called a loop. The loop continues to iterate until the condition is \code{False}, at which point any code after the loop and its associated lines are executed till the program ends.

\code{While} loops are used when the number of times the code has to run is unknown. However, a more common case is that the lines of code are executed for a fixed number of times. The \code{While} loop could be 'hacked' by coming up a with a condition that runs for a fixed number of times (like the example above), but there's a better way: \code{for} loops. These types of loops are extremely common, and most programming languages offer them. Compared to many other popular languages though, Python's \code{for} loop works a little differently: it is an iterator-based loop, similar to the \code{foreach} loop provided in C\# and VBA, or a version of the \code{for} loop in Java. It is not the same as the \code{for} loop used in C/C++.

An iterator is a specific type of Python object that allows the program to traverse through all the elements in a sequence (tuples, lists, or dictionaries), regardless of how that sequence is implemented. And since sequences have a fixed length at any point of time in a code, iterating through them is equivalent to running a loop for a fixed number of times. Consider the following block of code:

\begin{lstlisting}[frame=single] 
x = range(3)
print(list(x))
for i in x:
    print('The value of i is ',i)
\end{lstlisting}

Here, \code{range()} is a function that returns a fixed number of \textit{integers} (\textit{not floats}), \textit{starting from 0 by default}, although the default behavior can be modified (see \href{https://docs.python.org/3/library/functions.html#func-range}{documentation}). The return type is an iterable \code{range} object, which can be cast into a list type to see its contents - in this case, it's a list \code{[0,1,2]}.

Next, the \code{for} loop defines a variable \code{i} which is in \code{x}. This means that the variable \code{i} traverses through each the value in \code{x} in each iteration, until it runs out of values to traverse. Execute the function to print \code{i} and see this for yourself. 

The beauty of this approach in Python and perhaps the most startling difference between it and the \code{for} loop in C/C++ is that the iterator can have any implementation - it can contain anything, not just numbers! Consider this example:

\begin{lstlisting}[frame=single] 
for i in ['Harry',(0,1,2),1]:
    print(i)
\end{lstlisting}

Here, \code{i} iterates over a list, which itself is composed of three items of three different data types: a string, a tuple (yes, a list can hold a tuple, or even another list), and an integer. And it does this naturally, without any additional code or typecasting necessary. This is a really big deal!

And it gets better - a single \code{for} loop can have more than one loop variable. Consider the following example:

\begin{lstlisting}[frame=single] 
x = [0,1,2]
y = [10,11,12]
z = [21,22,23]
print(list(zip(x,y,z)))
for i,j,k in zip(x,y,z):
    print(i,'+',j,'+',k,'=',i+j)
\end{lstlisting}

Here, the \code{zip()} function (see \href{https://docs.python.org/3.3/library/functions.html#zip}{documentation}) takes three lists (or technically, iterable objects) \textit{of the same length} (or it truncates to the shortest length) and combines them into an iterable object of tuples, with each tuple having three members. Then, the \code{for} loop \textbf{unpacks} the tuples into the constituent members, which can then be iterated over \textit{simultaneously}. Python also provides several functions to efficiently create complex iterable objects through the itertools package (see \href{https://docs.python.org/3/library/itertools.html}{documentation}). We'll see how to import a package later.  

Finally, because the \code{for} loop is based on an iterator, it can actually be used anywhere in a line of code, and not just in a formal loop. Consider the following piece of code, which creates a list of the squares of the first five whole numbers in just one line:

\begin{lstlisting}[frame=single] 
x = [i**2 for i in range(5)]
print(x)
\end{lstlisting}

This feature makes writing Python loops particularly elegant and simple.

\subsection{Break, Continue, and Pass}
Python provides three more useful features for loops:

\begin{itemize}
	\item \textbf{Break}: When executed, the code breaks out of the loop without performing any more iterations
	\item \textbf{Continue}: When executed, the code skips everything after that line and returns to the top of the loop to perform the next iteration
	\item \textbf{Pass}: When executed, the just ignores that line, but continues to execute to the rest of the code for that iteration (good for use as a placeholder)
\end{itemize}

The following code succinctly demonstrates all three statements:

\begin{lstlisting}[frame=single] 
for x in range(10):
    if x==3:
        continue
    if x==5:
        pass
    if x==8:
        break
    print(x)
\end{lstlisting}

Here, integers from 0 to 9 are iterated over the variable \code{x} and in general, the value of the integer is printed. However, when \code{x==3}, the loop reaches a \code{continue} statement, which means that the rest of the code is not executed and so 3 is not printed, while the loop continues with the next value. When \code{x==5}, a \code{pass} statement is executed, so the rest of the code is executed and 5 is printed and the loop continues. Finally, when \code{x==8}, a \code{break} statement is encountered, which forces to loop to end without being executed for the last value, 9. Try it yourself to see.

\newpage
\section{Functions}
In just a few pages, we've already learned all the basic building blocks of any Python program. Now, we can move to higher abstractions. These abstractions are useful in making code more efficient, readable, and modifiable, and while they are strictly speaking not necessary write a program, they are used universally to write a \textit{good} program.

The first abstraction is functions. Functions are bits of code that are separated from the main function, but can be called by the main function to perform a specific task. Functions have their own scope, which means that they cannot access variables in the main program, unless those variables explicitly passed to the function by the program. Here's a simple function that simply prints whatever input is passed to it:

\begin{lstlisting}[frame=single] 
def print_input(x):
    print(x)

k = 'Hello'
print_input(k)

j = 'How are you'
print_input(j)

x = 'I am good'
print_input(x)
\end{lstlisting}

Let's break this down. A function is defined with a \code{def} statement, followed by the name of the function (which generally follows the same rules as variable names), followed by any inputs within parentheses, and finally a colon. The colon, like with loops, implies that items indented below it are part of the function. In this case, the print statement is the only piece of code in the function. 

The main program comes after the function definition, without an indentation. This is not necessary - functions can be defined anywhere in the code, but should be defined before their first call. However, it is good practice to define all functions at the beginning of the program. In the main program, a string variable is defined and passed to the function (variables are passed by object reference, which means the value of its memory address is passed, but changing it involves the same principles as mutability).

\subsection{Passing Variables} 

Note that the name of the variable passed to the function (\code{k, j, m} here), and the name the function uses for it internally (\code{x} here) could be the same or different. It doesn't matter: the function has its own scope, which means within the function, \code{x} is the name of the variable, irrespective of whether another variable outside the code has the same name or not. Think of \code{x} as a local alias for whatever variable is passed to the function. Thus, when the function is called, it receives a copy of variables passed to it, executes its code, and then returns control to the main program. The function itself only has to be defined once and can be called repeatedly. Furthermore, if the function is changes, it only has to be changed once, instead of having to change every instance of the same code.

However, the data type of the variable passed to the function may be important. Consider the following piece of code:

\begin{lstlisting}[frame=single] 
def add5(x):
    y = []
    for i in x:
        y.append(i+5)
    return y

a = ['one','two']
b = add5(a)
print(b)
\end{lstlisting}

Here, a function \code{add5(x)} is defined, which takes in a collection called \code{x}. Within the function, an empty list \code{y} is initialized. Then, every value in \code{x} is iterated over, with a value of 5 added to it, and the new value appended to \code{y}. Once all values are exhausted, the function returns \code{y} to the main program with a \code{return} statement. In the main program, a list of stings \code{a} is created and passed to the \code{add5()} function, and the value returned from it is stored in the variable \code{b}. This won't work however: a string cannot be added to an integer, and so the function will return an error. Thus, in this case, it is important to check what type of data is passed to the function. Change the main program to define \code{a = range(3)} and see what it returns. 

\subsection{Multiple Inputs and Outputs}

A function can take in any number of variables and also return any number. Consider a function \code{solve\_eqs()} to solve the system of linear equations $ax+by=e$ and $cx+dy=f$, whose solution is $x=(de-bf)/(ad-bc)$ and $y=(af-ce)/(ad-bc)$. The function takes in the constants \code{a,b,c,d,e,f} and returns the value of \code{x,y}:

\begin{lstlisting}[frame=single] 
def solve_eqs(a,b,c,d,e,f):
    if (a*d-b*c)==0:
        return 'Error'
    x = (d*e-b*f)/(a*d-b*c)
    y = (a*f-c*e)/(a*d-b*c)
    return (x,y)

a = solve_eqs(3.2,3.2,7.8,7.8,1.3,2.4)
print(a)
\end{lstlisting}

The function first checks whether a unique solution exists, and if it doesn't, it returns 'Error' to both the expected variables \code{x,y} (there are better ways to handle this, but it's good enough to get the point). After the first \code{return} statement is executed, control returns to the main program, irrespective of whether any more lines could have been executed in the function. If a unique solution does exist, the \code{if} statement's condition is false and the first return statement is not executed. Then, the values of \code{x,y} are evaluated and returned as a tuple. In the main program, the output from the function is stored and printed in \code{a}. Try changing the inputs to the function call and see the results.

\subsection{Keyword and Default Arguments}

There are two more things to keep in mind: keyword arguments and default arguments. Consider the \code{solve\_eqs()} function above: it has a lot of inputs, and the programmer has to input them in exactly the right order. This can get confusing. Fortunately, Python allows the function call to include the the name of the variable (also called an \textbf{argument}) being passed. In the code above, change line 8 to the following and see this in action:

\begin{lstlisting}[frame=single] 
a = solve_eqs(a=3.2,f=3.2,d=7.8,b=7.8,c=1.3,e=2.4)
\end{lstlisting}

This method of passing variables is called keyword arguments (where the name of the variable inside the function becomes its keyword in the function call). With this, arguments can be passed in any order without confusion. 

Python can also assume some default values for arguments, which will be used if the user does not pass that particular argument. Consider this code:

\begin{lstlisting}[frame=single] 
def addnumber(x,n=5):
    y = []
    for i in x:
        y.append(i+n)
    return y

a = range(3)
print(addnumber(a))
print(addnumber(a,n=2))
\end{lstlisting}

This code defines a function \code{addnumber()}, which is similar to the \code{add5()} function defined previously, but takes an extra argument: the number to add to the first variable \code{n}, which is set to 5 in the function definition. Consider the first function call in the main program: only one variable is passed, so the function will use the default value of \code{n}. In the second call, both variables are passed, and the function uses the value of \code{n} passed in the call. Note that variables with default values are usually defined at the end of a function definition, and it is good practice to pass them using keywords to avoid confusion, as shown above.

\newpage
\section{Classes and Objects}
The last abstraction that is useful but not necessary is classes, and objects created from those classes. Think of a class as a set of related variables and functions that are logically grouped together, and \textbf{an object as an instance of a class}. Let's take a concrete example: a person. What are the characteristics of a person? Their name, age, and height. Let's say the height is in centimeters, and we'd like a function to tell us what it is in feet and inches. These variables and functions can be grouped together into a logical class, and then we can create objects from those classes for every person we have data for. Let's put this into practice below. 

\subsection{Defining a Class}
The \code{Person} class described above is constructed in the following code, after which an object is created from it:

\begin{lstlisting}[frame=single] 
class Person:   
    def __init__(self,name,age,height_cm):
        self.name = name
        self.age = age
        self.height_cm = height_cm #in centimeters
    
    def print_name(self):
        print(self.name)
    
    def print_age(self):
        print(self.age)
    
    def print_height_cm(self):
        print(self.height_cm)
    
    def height_ftin(self):
        inches = self.height_cm/2.54
        feet = inches//12
        inches = inches%12
        return feet,inches

adam = Person('Adam Levine',38,190)
adam.print_name()
adam.print_age()
adam.print_height_cm()

feet,inches = adam.height_ftin()
print('Height is ',feet,' ft and ',
      "{:.1f}".format(inches),' in')
\end{lstlisting}

Like a function, a class is defined by prefixing it with a keyword \code{class} followed by the name of the class and colon. All indented lines after the colon represent the member variables and functions of that class. Within the class, member variables like \code{gender} and member functions can be defined. A class definition usually contains a special function \code{\_\_init\_\_()}, which is called a \textbf{constructor}. A constructor, as the name suggests, can be used to create an object of a class by creating variables and setting their values (unlike other object-oriented languages, a Python class can have only one constructor). Note that any member function, including a constructor, is defined just like any other Python function, with appropriate indentation for lines associated with that function. However, unlike ordinary Python functions, member functions of a class \textbf{must} be passed a \code{self} argument at the very beginning, as this is necessary for the function to be associated with the object.

In the \code{Person} class above, the constructor has four arguments: \code{self, name, age, height\_cm}. The last three are self-explanatory, while \code{self} is a reference to the class itself (or strictly speaking, the object, similar to a \code{this} pointer in C++). The \code{self} argument is usually provided to all functions in a class so that they can access the variables in the associated object using the dot (.) operator. Consider the constructor above: it takes the value of the \code{name} variable passed to it and stores it in a \textbf{local} variable, also called \code{name} (it could've been called something else too). It knows that this is a local variable because it is defined using \code{self.name}, which implies that it is a member of the object itself. Thus, the dot operator is used to access member variables and functions. A similar operation is performed for the other member variables, \code{age, height\_cm}. Then, four more member functions are defined, which are also self-explanatory. Remember, all members functions must be passed a \code{self} argument in addition to any other optional arguments, \textit{even if it never uses any local variables}. Similar to regular Python functions, member functions can also return values, like the \code{height\_ftin()} function defined above.

Now that we've defined the class, we can create an object, which is an instance of the class. This means that the object is a specific implementation of a class. In the code above, this is defined similar to how a new variable is defined. An object called \code{adam} is created and the \code{Person} class is assigned to it. In this assignment, the constructor of the \code{Person} class is called, which needs the \code{name, age, height\_cm} variables, which are thus provided. Below that, members functions are used to print the objects's name, age, and height in cm, and to obtain the height in feet and inches. These member functions are accessed using the dot operator on the object, similar to how we used the dot operator on \code{self} to access members in the definition of the class.

\subsection{Inheritance}
Classes can seem unwieldy at first, but they are actually very useful in writing well-organized and efficient code. One of the most useful features of classes is called inheritance: the ability of a class to inherit all the members of a parent or \textit{base} class while adding more to itself. This allows for a more granular level of abstraction. Let's see this with a concrete example: consider a student. A student is also a person (and thus has all the features of a person), but they have more features unique to them: GPA and level of study. We can define a class \code{Student} that inherits all the members of the \code{Parent} class, but also has these extra members:

\begin{lstlisting}[frame=single] 
class Student(Person):
    def __init__(self,name,age,height_cm,GPA,level):
        Person.__init__(self,name,age,height_cm)
        self.GPA = GPA
        self.level = level
    
    def print_name(self,status='regular'):
        print(self.name,' STUDENT: ',status)
    
    def print_GPA(self):
        print(self.GPA)
    
    def print_level(self):
        print(self.level)

nicole = Student('Nicole Kidman',19,170,3.6,'freshman')

nicole.print_name('in absentia')
nicole.print_age()
nicole.print_height_cm()
nicole.print_GPA()
nicole.print_level()

feet,inches = nicole.height_ftin()
print('Height is ',feet,' ft and ',
      "{:.1f}".format(inches),' in')
\end{lstlisting}

Once again, a class \code{Student} is defined with the \code{class} keyword, but this time, the class is also passed the \code{Person} class so that it inherits from it. The inherited class has all the members of the base class, and can change them if necessary. The constructor is defined as usual, with the necessary variables passed to it and stored in local member variables. However, within the constructor, variables that were inherited from the base class can be initialized using the constructor of the base class, which can be accessed with the dot operator. This avoids having to rewrite lines of code that were already written for the base class' constructor, with code being written only for the variables unique to the child class.

After the constructor, the \code{Student} class has access to all the member functions of its base class, and thus, they do not have to be rewritten. Three new member functions are created: \code{print\_GPA()} and \code{print\_level()}, which are self-explanatory, and a new \code{print\_name()} that overwrites the function of the same name in the base class by appending the name of the person with the word STUDENT, and accepting a new argument \code{status} with a specified default value. 

Thus, the child class not only has access to the members functions of the base class, but can \textit{also} change them by changing the implementation of the function and also the number of arguments. This ability of functions with the same name to do different things in different situations is called \textbf{polymorphism}. Indeed, it would've also been possible to define the \code{print\_name()} function in the base \code{Person} class \textit{without any implementation at all}, and then allow all child classes to have their own specific implementations of it. Such a class, which only has the name of a function but no implementation, is called an \textbf{Abstract Base Class (ABC)}. Polymorphism and ABCs form the basis of modern object-oriented programming.

The definition  of the child class is followed by defining an object in the main program, and then all its member functions are called. Try to do this yourself to see the result.

\newpage
\section{Challenge: Basic Python}
That's all you needed to know about Python! Well, that's all the theory anyway. Like a human language, programming languages cannot be learned by listening to someone in a classroom or reading a book. They can only be learned through practice, and Python is no different. You can find a good list of practice exercises \href{https://www.practicepython.org/}{here}. In this section though, we'll solve one problem using all the tools we've learned so far.

\subsection{Problem Statement}


\end{document}